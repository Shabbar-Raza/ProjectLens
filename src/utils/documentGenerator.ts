import { ProjectAnalysis, GeneratedDoc, ProjectFile, DependencyInfo, FileAnalysis } from '../types';

export class DocumentGenerator {
  static generate(analysis: ProjectAnalysis): GeneratedDoc {
    const sections = {
      overview: this.generateOverview(analysis),
      architecture: this.generateArchitecture(analysis),
      structure: this.generateStructure(analysis.structure),
      dependencies: this.generateDependencies(analysis),
      components: this.generateComponents(analysis),
      dataFlow: this.generateDataFlow(analysis),
      gettingStarted: this.generateGettingStarted(analysis)
    };

    const content = this.generateStandardDoc(analysis, sections);
    const aiOptimized = this.generateAIOptimizedDoc(analysis, sections);
    const metadata = this.generateMetadata(analysis);

    return { content, aiOptimized, sections, metadata };
  }

  private static generateStandardDoc(analysis: ProjectAnalysis, sections: any): string {
    return `# ${analysis.name}

${sections.overview}

${sections.architecture}

## ğŸ“ Source Structure

${sections.structure}

## ğŸ”§ Key Dependencies

${sections.dependencies}

## ğŸ“‹ Core Components

${sections.components}

## ğŸ”— Data Flow

${sections.dataFlow}

## ğŸš€ Getting Started

${sections.gettingStarted}

---
*Generated by CodeContext Pro - AI Documentation Generator*
`;
  }

  private static generateAIOptimizedDoc(analysis: ProjectAnalysis, sections: any): string {
    return `# CODEBASE CONTEXT FOR AI ASSISTANT

## PROJECT TYPE: ${analysis.type.toUpperCase()}

## MAIN TECHNOLOGIES:
${this.generateTechStack(analysis)}

## KEY FILES TO UNDERSTAND:
${this.generateKeyFiles(analysis)}

## COMPONENT STRUCTURE:
${this.generateComponentStructure(analysis)}

## ARCHITECTURE PATTERNS:
${analysis.architecture.patterns.map(pattern => `- ${pattern}`).join('\n')}

## ENTRY POINTS:
${analysis.entryPoints.map(entry => `- \`${entry}\``).join('\n')}

## CURRENT TASK CONTEXT:
[Space for user to add specific context about what they're working on]

---

## DETAILED COMPONENT BREAKDOWN:

${this.generateDetailedComponents(analysis)}

## DEPENDENCIES & IMPORTS:
${this.generateImportMap(analysis)}

## CODING PATTERNS USED:
${this.generateCodingPatterns(analysis)}
`;
  }

  private static generateOverview(analysis: ProjectAnalysis): string {
    const stats = this.calculateStats(analysis);
    
    let overview = `## ğŸ—ï¸ Architecture Overview\n\n`;
    
    if (analysis.packageInfo?.description) {
      overview += `**Description:** ${analysis.packageInfo.description}\n\n`;
    }
    
    overview += `**Project Type:** ${this.getProjectTypeDescription(analysis.type)}\n`;
    overview += `**Build Tool:** ${analysis.architecture.buildTool || 'Not detected'}\n\n`;
    
    overview += `**Statistics:**\n`;
    overview += `- ğŸ“ **Source Files:** ${stats.sourceFiles}\n`;
    overview += `- âš¡ **Components:** ${stats.components}\n`;
    overview += `- ğŸ”§ **Services:** ${stats.services}\n`;
    overview += `- ğŸ—ï¸ **Classes:** ${stats.classes}\n`;
    overview += `- ğŸ“¦ **Dependencies:** ${analysis.dependencies.length}\n\n`;

    if (analysis.packageInfo?.version) {
      overview += `**Version:** ${analysis.packageInfo.version}\n\n`;
    }

    return overview;
  }

  private static generateArchitecture(analysis: ProjectAnalysis): string {
    let arch = `## ğŸ›ï¸ Architecture\n\n`;
    
    arch += `**Technologies:**\n`;
    analysis.architecture.technologies.forEach(tech => {
      arch += `- ${tech}\n`;
    });
    arch += '\n';
    
    if (analysis.architecture.patterns.length > 0) {
      arch += `**Patterns:**\n`;
      analysis.architecture.patterns.forEach(pattern => {
        arch += `- ${pattern}\n`;
      });
      arch += '\n';
    }
    
    if (analysis.entryPoints.length > 0) {
      arch += `**Entry Points:**\n`;
      analysis.entryPoints.forEach(entry => {
        arch += `- \`${entry}\`\n`;
      });
      arch += '\n';
    }
    
    return arch;
  }

  private static generateStructure(structure: ProjectFile): string {
    const generateTree = (node: ProjectFile, level = 0): string => {
      if (node.ignored) return '';
      
      const indent = '  '.repeat(level);
      const icon = node.type === 'directory' ? 'ğŸ“' : this.getFileIcon(node.name);
      let result = `${indent}- ${icon} **${node.name}**`;
      
      // Add file category and size info
      if (node.type === 'file') {
        if (node.category) {
          result += ` *(${node.category})*`;
        }
        if (node.size && node.size > 1024) {
          result += ` *[${Math.round(node.size / 1024)}KB]*`;
        }
      }
      
      result += '\n';
      
      if (node.children && node.children.length > 0) {
        const visibleChildren = node.children.filter(child => !child.ignored);
        const sortedChildren = [...visibleChildren].sort((a, b) => {
          if (a.type === b.type) return a.name.localeCompare(b.name);
          return a.type === 'directory' ? -1 : 1;
        });
        
        for (const child of sortedChildren) {
          result += generateTree(child, level + 1);
        }
      }
      
      return result;
    };

    return '```\n' + generateTree(structure) + '```\n';
  }

  private static generateDependencies(analysis: ProjectAnalysis): string {
    let deps = '';
    
    // Categorize dependencies
    const categories = this.categorizeDependencies(analysis.dependencies);
    
    Object.entries(categories).forEach(([category, categoryDeps]) => {
      if (categoryDeps.length > 0) {
        deps += `### ${category}\n\n`;
        categoryDeps.forEach(dep => {
          deps += `- **${dep.name}** (${dep.version})`;
          if (dep.description) {
            deps += ` - ${dep.description}`;
          }
          deps += '\n';
        });
        deps += '\n';
      }
    });
    
    if (deps === '') {
      deps = 'No key dependencies found.\n\n';
    }
    
    return deps;
  }

  private static generateComponents(analysis: ProjectAnalysis): string {
    let content = '';
    
    // Group files by category
    const categories = this.groupFilesByCategory(analysis.files);
    
    Object.entries(categories).forEach(([category, files]) => {
      if (files.length === 0) return;
      
      content += `### ${this.getCategoryTitle(category)}\n\n`;
      
      files.forEach(file => {
        content += `**${file.path}**\n`;
        
        // Add functions
        if (file.functions.length > 0) {
          const mainFunctions = file.functions.filter(f => f.name.length > 1).slice(0, 5);
          mainFunctions.forEach(func => {
            const params = func.parameters.length > 0 ? func.parameters.join(', ') : '';
            const returnType = func.returnType ? `: ${func.returnType}` : '';
            const asyncLabel = func.isAsync ? ' *(async)*' : '';
            const exportLabel = func.isExported ? ' *(exported)*' : '';
            
            content += `- \`${func.name}(${params})${returnType}\`${asyncLabel}${exportLabel}`;
            if (func.description) {
              content += ` - ${func.description}`;
            }
            content += '\n';
          });
        }
        
        // Add classes
        if (file.classes.length > 0) {
          file.classes.forEach(cls => {
            content += `- **Class: ${cls.name}**`;
            if (cls.extends) content += ` extends ${cls.extends}`;
            if (cls.description) content += ` - ${cls.description}`;
            content += '\n';
            
            // Show main methods
            const mainMethods = cls.methods.slice(0, 3);
            mainMethods.forEach(method => {
              content += `  - \`${method.name}(${method.parameters.join(', ')})\`\n`;
            });
          });
        }
        
        // Add interfaces
        if (file.interfaces.length > 0) {
          file.interfaces.forEach(iface => {
            content += `- **Interface: ${iface.name}**\n`;
            const mainProps = iface.properties.slice(0, 3);
            mainProps.forEach(prop => {
              content += `  - \`${prop.name}: ${prop.type || 'any'}\`\n`;
            });
          });
        }
        
        content += '\n';
      });
    });
    
    return content || 'No components found.\n\n';
  }

  private static generateDataFlow(analysis: ProjectAnalysis): string {
    let content = '';
    
    // Analyze import relationships
    const importMap = new Map<string, string[]>();
    const exportMap = new Map<string, string[]>();
    
    analysis.files.forEach(file => {
      // Track imports
      file.imports.forEach(imp => {
        if (imp.source.startsWith('./') || imp.source.startsWith('../')) {
          if (!importMap.has(imp.source)) {
            importMap.set(imp.source, []);
          }
          importMap.get(imp.source)!.push(file.path);
        }
      });
      
      // Track exports
      if (file.exports.length > 0) {
        exportMap.set(file.path, file.exports.map(exp => exp.name));
      }
    });
    
    if (importMap.size > 0) {
      content += '### Internal Dependencies\n\n';
      importMap.forEach((importers, source) => {
        content += `**${source}**\n`;
        importers.forEach(importer => {
          content += `- â† Used by: \`${importer}\`\n`;
        });
        content += '\n';
      });
    }
    
    // Show component hierarchy for React projects
    if (analysis.type === 'react') {
      content += this.generateReactComponentFlow(analysis);
    }
    
    return content || 'No clear data flow patterns detected.\n\n';
  }

  private static generateGettingStarted(analysis: ProjectAnalysis): string {
    let content = '';
    
    if (analysis.packageInfo?.scripts) {
      content += '### Available Scripts\n\n';
      const importantScripts = ['start', 'dev', 'build', 'test', 'lint'];
      
      importantScripts.forEach(scriptName => {
        if (analysis.packageInfo!.scripts![scriptName]) {
          content += `- **${scriptName}**: \`npm run ${scriptName}\`\n`;
          content += `  - ${analysis.packageInfo!.scripts![scriptName]}\n`;
        }
      });
      content += '\n';
    }
    
    // Add setup instructions based on project type
    content += this.generateSetupInstructions(analysis);
    
    // Add key comments
    const keyComments = analysis.files
      .flatMap(file => file.comments)
      .filter(comment => comment.length > 30)
      .slice(0, 3);
      
    if (keyComments.length > 0) {
      content += '### Key Notes\n\n';
      keyComments.forEach(comment => {
        content += `> ${comment}\n\n`;
      });
    }
    
    return content;
  }

  // Helper methods for AI-optimized documentation
  private static generateTechStack(analysis: ProjectAnalysis): string {
    let stack = '';
    
    if (analysis.type) {
      stack += `- **Framework**: ${analysis.type}\n`;
    }
    
    if (analysis.architecture.buildTool) {
      stack += `- **Build Tool**: ${analysis.architecture.buildTool}\n`;
    }
    
    // Add main dependencies
    const mainDeps = analysis.dependencies
      .filter(dep => ['framework', 'ui', 'styling'].includes(dep.category))
      .slice(0, 5);
      
    mainDeps.forEach(dep => {
      stack += `- **${dep.name}**: ${dep.version}\n`;
    });
    
    return stack;
  }

  private static generateKeyFiles(analysis: ProjectAnalysis): string {
    const keyFiles = analysis.files
      .filter(file => file.isEntryPoint || file.category === 'component' || file.functions.length > 3)
      .slice(0, 8)
      .map((file, index) => {
        const description = this.getFileDescription(file);
        return `${index + 1}. \`${file.path}\` - ${description}`;
      });
      
    return keyFiles.join('\n');
  }

  private static generateComponentStructure(analysis: ProjectAnalysis): string {
    const components = analysis.files.filter(file => file.category === 'component');
    
    return components.slice(0, 10).map(comp => {
      const mainFunction = comp.functions.find(f => f.name.match(/^[A-Z]/)) || comp.functions[0];
      if (mainFunction) {
        return `- \`${mainFunction.name}\` - ${this.getFileDescription(comp)}`;
      }
      return `- \`${comp.path}\` - ${this.getFileDescription(comp)}`;
    }).join('\n');
  }

  private static generateDetailedComponents(analysis: ProjectAnalysis): string {
    let content = '';
    
    const importantFiles = analysis.files
      .filter(file => file.functions.length > 0 || file.classes.length > 0)
      .slice(0, 15);
      
    importantFiles.forEach(file => {
      content += `### ${file.path}\n`;
      content += `**Category**: ${file.category} | **Complexity**: ${file.complexity}\n\n`;
      
      if (file.functions.length > 0) {
        content += '**Functions:**\n';
        file.functions.slice(0, 5).forEach(func => {
          content += `- \`${func.name}(${func.parameters.join(', ')})\``;
          if (func.description) content += ` - ${func.description}`;
          content += '\n';
        });
        content += '\n';
      }
      
      if (file.classes.length > 0) {
        content += '**Classes:**\n';
        file.classes.forEach(cls => {
          content += `- \`${cls.name}\``;
          if (cls.description) content += ` - ${cls.description}`;
          content += '\n';
        });
        content += '\n';
      }
    });
    
    return content;
  }

  private static generateImportMap(analysis: ProjectAnalysis): string {
    const externalImports = new Set<string>();
    const internalImports = new Map<string, string[]>();
    
    analysis.files.forEach(file => {
      file.imports.forEach(imp => {
        if (imp.source.startsWith('./') || imp.source.startsWith('../')) {
          if (!internalImports.has(file.path)) {
            internalImports.set(file.path, []);
          }
          internalImports.get(file.path)!.push(imp.source);
        } else {
          externalImports.add(imp.source);
        }
      });
    });
    
    let content = '**External Dependencies:**\n';
    Array.from(externalImports).slice(0, 10).forEach(dep => {
      content += `- ${dep}\n`;
    });
    
    content += '\n**Internal Imports:**\n';
    Array.from(internalImports.entries()).slice(0, 8).forEach(([file, imports]) => {
      content += `- \`${file}\` imports: ${imports.join(', ')}\n`;
    });
    
    return content;
  }

  private static generateCodingPatterns(analysis: ProjectAnalysis): string {
    const patterns = new Set<string>();
    
    analysis.files.forEach(file => {
      if (file.functions.some(f => f.isAsync)) patterns.add('Async/Await pattern');
      if (file.classes.length > 0) patterns.add('Object-oriented programming');
      if (file.functions.some(f => f.name.startsWith('use'))) patterns.add('React Hooks');
      if (file.exports.some(e => e.isDefault)) patterns.add('ES6 modules with default exports');
      if (file.interfaces.length > 0) patterns.add('TypeScript interfaces');
    });
    
    return Array.from(patterns).map(pattern => `- ${pattern}`).join('\n');
  }

  // Utility methods
  private static calculateStats(analysis: ProjectAnalysis) {
    return {
      sourceFiles: analysis.files.length,
      components: analysis.files.filter(f => f.category === 'component').length,
      services: analysis.files.filter(f => f.category === 'service').length,
      classes: analysis.files.reduce((sum, f) => sum + f.classes.length, 0)
    };
  }

  private static getProjectTypeDescription(type: string): string {
    const descriptions = {
      'react': 'React Application',
      'vue': 'Vue.js Application',
      'angular': 'Angular Application',
      'nextjs': 'Next.js Application',
      'node': 'Node.js Application',
      'express': 'Express.js Server',
      'python': 'Python Application',
      'java': 'Java Application'
    };
    
    return descriptions[type] || 'Web Application';
  }

  private static categorizeDependencies(dependencies: DependencyInfo[]) {
    const categories = {
      'Core Framework': dependencies.filter(d => d.category === 'framework'),
      'UI & Styling': dependencies.filter(d => ['ui', 'styling'].includes(d.category)),
      'Development Tools': dependencies.filter(d => ['build', 'testing'].includes(d.category)),
      'Utilities': dependencies.filter(d => d.category === 'utility'),
      'Other': dependencies.filter(d => d.category === 'other')
    };
    
    return categories;
  }

  private static groupFilesByCategory(files: FileAnalysis[]) {
    return {
      'component': files.filter(f => f.category === 'component'),
      'service': files.filter(f => f.category === 'service'),
      'utility': files.filter(f => f.category === 'utility'),
      'type': files.filter(f => f.category === 'type'),
      'config': files.filter(f => f.category === 'config'),
      'other': files.filter(f => !['component', 'service', 'utility', 'type', 'config'].includes(f.category))
    };
  }

  private static getCategoryTitle(category: string): string {
    const titles = {
      'component': 'Components',
      'service': 'Services & APIs',
      'utility': 'Utilities & Helpers',
      'type': 'Types & Interfaces',
      'config': 'Configuration',
      'other': 'Other Files'
    };
    
    return titles[category] || category;
  }

  private static getFileDescription(file: FileAnalysis): string {
    if (file.framework === 'react' && file.category === 'component') {
      return 'React component';
    }
    
    if (file.category === 'service') {
      return 'Service/API layer';
    }
    
    if (file.isEntryPoint) {
      return 'Application entry point';
    }
    
    if (file.functions.length > 5) {
      return 'Utility functions';
    }
    
    if (file.classes.length > 0) {
      return `Contains ${file.classes.length} class(es)`;
    }
    
    return `${file.category} file`;
  }

  private static generateReactComponentFlow(analysis: ProjectAnalysis): string {
    const components = analysis.files.filter(f => f.framework === 'react');
    if (components.length === 0) return '';
    
    let content = '### React Component Hierarchy\n\n';
    
    // Find App component
    const appComponent = components.find(c => c.path.includes('App.'));
    if (appComponent) {
      content += `**App Component** (\`${appComponent.path}\`)\n`;
      
      // Find components imported by App
      appComponent.imports
        .filter(imp => imp.source.startsWith('./'))
        .forEach(imp => {
          content += `- Uses: \`${imp.source}\`\n`;
        });
    }
    
    return content + '\n';
  }

  private static generateSetupInstructions(analysis: ProjectAnalysis): string {
    let instructions = '### Setup Instructions\n\n';
    
    instructions += '1. **Install dependencies:**\n';
    instructions += '   ```bash\n   npm install\n   ```\n\n';
    
    if (analysis.packageInfo?.scripts?.dev) {
      instructions += '2. **Start development server:**\n';
      instructions += '   ```bash\n   npm run dev\n   ```\n\n';
    } else if (analysis.packageInfo?.scripts?.start) {
      instructions += '2. **Start the application:**\n';
      instructions += '   ```bash\n   npm start\n   ```\n\n';
    }
    
    if (analysis.packageInfo?.scripts?.build) {
      instructions += '3. **Build for production:**\n';
      instructions += '   ```bash\n   npm run build\n   ```\n\n';
    }
    
    return instructions;
  }

  private static generateMetadata(analysis: ProjectAnalysis) {
    return {
      fileCount: analysis.files.length,
      componentCount: analysis.files.filter(f => f.category === 'component').length,
      serviceCount: analysis.files.filter(f => f.category === 'service').length,
      totalLines: analysis.files.reduce((sum, file) => {
        return sum + (file.functions.length * 10) + (file.classes.length * 20); // Rough estimate
      }, 0)
    };
  }

  private static getFileIcon(filename: string): string {
    const ext = filename.split('.').pop()?.toLowerCase();
    
    switch (ext) {
      case 'js': case 'jsx': return 'âš¡';
      case 'ts': case 'tsx': return 'ğŸ”·';
      case 'vue': return 'ğŸ’š';
      case 'svelte': return 'ğŸ§¡';
      case 'py': return 'ğŸ';
      case 'java': return 'â˜•';
      case 'cpp': case 'c': return 'âš™ï¸';
      case 'go': return 'ğŸ”µ';
      case 'rs': return 'ğŸ¦€';
      case 'php': return 'ğŸ˜';
      case 'rb': return 'ğŸ’';
      case 'css': case 'scss': case 'sass': case 'less': return 'ğŸ¨';
      case 'json': return 'ğŸ“‹';
      case 'md': return 'ğŸ“';
      case 'html': return 'ğŸŒ';
      case 'yml': case 'yaml': return 'âš™ï¸';
      default: return 'ğŸ“„';
    }
  }
}